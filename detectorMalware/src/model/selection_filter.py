#! - * - coding UTF-8 - * -

from src.mongo.database import DataBaseMongo
from pymongo import ASCENDING,IndexModel,DESCENDING
import numpy as np



def calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collections_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collections_discreeting.drop()
    query = collection_features.aggregate([{'$sort': {'feature' : -1,
                                                      'n_count': -1,
                                                      'label': -1}},
                                           {'$group': {'_id': '$feature',
                                                       'data': {'$addToSet': {'index': '$index_file',
                                                                              'label': '$label'}}}}],
                                          allowDiskUse=True)
    for value in query:
        discrete = list()
        part = list()
        length_value = len(value['data'])
        if length_value <= 2:
            continue
        list_index = [index for index in range(lenghtDB)]
        label_element_prior = value['data'][0]['label']
        index_element_prior = value['data'][0]['index']
        list_index.remove(index_element_prior)
        part.append(index_element_prior)
        label_element = value['data'][1]['label']
        index_element = value['data'][1]['index']
        list_index.remove(index_element)
        for index in range(2, length_value):
            if ((not (label_element_prior == label_element)) or (not (label_element == value['data'][index]['label']))):
                discrete.append(part)
                part = list()
            part.append(index_element)
            label_element_prior, index_element_prior = label_element, index_element
            label_element = value['data'][index]['label']
            index_element = value['data'][index]['index']
            list_index.remove(index_element)
        part.append(index_element)
        discrete.append(part)
        size = 0
        for sub_part in discrete:
            size += len(sub_part)
        assert size == length_value, "Reveiw discreeting."
        if len(list_index) > 0:
            discrete.append(list_index)
        collections_discreeting.insert_one(
            {'feature': value['_id'], 'num_files': length_value, 'discreeting': discrete, 'k': len(discrete)})



def calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, num_features, lenghtDB):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2])
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$match': {}}, {'$out': prefix_collection + '_aux_' + namesCollections[2]}])
    collection_aux_ranking.create_index([('feature', ASCENDING)], unique=True)
    del collection_discreeting
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    collection_ranking_su.drop()
    index1 = IndexModel([('feature', ASCENDING)])
    index2 = IndexModel([('feature_prior', ASCENDING)])
    collection_ranking_su.create_index([index1, index2])
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_mi')
    collection_ranking_mi.drop()
    index = IndexModel([('mi', DESCENDING), ('feature', ASCENDING)])
    collection_ranking_mi.create_index(index)
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    feature_prior=('label', [[i for i in range(lenghtDB)]])
    for index in range(num_features):
        query = collection_aux_ranking.aggregate(
            [{'$sort': {'feature': 1}}, {'$project': {'_id': 0, 'feature': 1, 'discreeting': 1}}], allowDiskUse=True)
        for feature in query:
            calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], data, 9, feature_prior, feature)
        query_ranking = collection_ranking.aggregate(
            [{'$group': {'_id': None, 'total_su': {'$sum': '$su'}, 'features': {'$addToSet': '$feature'}}},
             {'$project': {'_id': 0}}], allowDiskUse=True)
        try:
            elements_ranking = query_ranking.next()
        except Exception as e:
            elements_ranking = {'total_su': 0, 'features': []}
        query = collection_ranking_su.aggregate(
            [{'$match':{'feature_prior':feature_prior[0]}},
             {'$sort': {'feature': 1}}], allowDiskUse=True)
        collection_ranking_mi.drop()
        for feature in query:
            calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], elements_ranking, feature)
        best_mi = collection_ranking_mi.aggregate([{'$sort':{'mi':-1, 'feature':1}},{'$limit':1}],allowDiskUse=True).next()
        best_mi['position'] = index
        discreeting = collection_aux_ranking.find_one({'feature':best_mi['feature']})
        del best_mi['_id']
        feature_prior = (best_mi['feature'], discreeting['discreeting'])
        collection_aux_ranking.delete_one(discreeting)
        collection_ranking.insert(best_mi)



def calculate_num_labels(data, array, labels):
    data_labels = np.ones(labels)
    for value in data[list(array)]:
        if value > 0:
            data_labels[value - 1] += 1
    return data_labels


def calculateEntropy(data, discrete, labels):
    entropy = np.zeros(len(discrete))
    total_elements = np.zeros(len(discrete))
    for index, array in enumerate(discrete):
        data_labels = calculate_num_labels(data, array, labels)
        data_labels = np.reshape(data_labels[np.argwhere(data_labels > 0)], len(np.argwhere(data_labels > 0)))
        num_elements_array = np.sum(data_labels)
        total_elements += num_elements_array
        data_labels = data_labels / num_elements_array
        entropy[index] = num_elements_array * (-np.sum(data_labels * np.log(data_labels)))
    return np.sum(entropy / total_elements)

def calculateSymmetricUncertainty(data, discrete, discrete_prior, num_labels):
    entropy_class = calculateEntropy(data, discrete_prior, num_labels)
    entropy_class_feature = calculateEntropy(data, discrete, num_labels)
    feature = np.zeros(len(data), dtype=int)
    for index, value in enumerate(discrete):
        for aux_value in value:
            feature[aux_value] = index + 1
    discrete_feature = np.reshape(np.arange(0, len(data)), (1, len(data)))
    entropy_featue = calculateEntropy(feature, discrete_feature, len(discrete))
    return (2*(entropy_class - entropy_class_feature)/entropy_featue)/ (entropy_class + entropy_featue)


def calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, name_collection, data, num_labels, feature_prior, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    su = calculateSymmetricUncertainty(data,feature['discreeting'],feature_prior[1],num_labels)
    collection_ranking_su.insert({'feature':feature['feature'], 'feature_prior':feature_prior[0], 'su':su})
    del db, collection_ranking_su

def calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, name_collection, elements_ranking, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + name_collection + '_mi')
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    array = list(elements_ranking['features'])
    if not isinstance(array,list):
        print(array)

    array.append(feature['feature'])
    query_su = collection_ranking_su.aggregate([{'$match': {'feature_prior': {'$ne': 'label'},
                                                            'feature':{'$in':array}}},
                                                {'$group': {'_id': None,
                                                            'total_su': {'$sum': '$su'}}}], allowDiskUse=True)
    try:
        feature_su = query_su.next()['total_su']
    except Exception as e:
        feature_su = 0
    mi = elements_ranking['total_su']+collection_ranking_su.find_one({'feature':feature['feature'],'feature_prior':'label'})['su'] -(0.5*feature_su)
    feature['mi']=mi
    collection_ranking_mi.insert(feature)
    del db, collection_ranking_su, collection_ranking_mi
