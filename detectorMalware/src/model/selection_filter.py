#! - * - coding UTF-8 - * -

from src.mongo.database import DataBaseMongo
from pymongo import ASCENDING,DESCENDING
import numpy as np
from pymongo.errors import CursorNotFound,AutoReconnect
from multiprocessing import Pool
from functools import partial

def calculateDiscreetingOneElement(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB, discrete_feature, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collections_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collections_aux_discreeting = db.selectCollection(prefix_collection + '_aux_' + namesCollections[3])
    query = collection_features.aggregate([{'$match':{'feature':feature['_id']}},
                                           {'$sort': {'n_count': -1,
                                                      'label': -1}},
                                           {'$group': {'_id': '$feature',
                                                       'data': {'$addToSet': {'index': '$index_file',
                                                                              'label': '$label'}}}}],
                                          allowDiskUse=True)
    for value in query:
        length_value = len(value['data'])
        if length_value <= 2:
            continue
        discrete = list()
        part = list()
        num_part = 1
        list_index = [index for index in range(lenghtDB)]
        data_feature = np.zeros(lenghtDB, dtype=int)
        label_element_prior = value['data'][0]['label']
        index_element_prior = value['data'][0]['index']
        list_index.remove(index_element_prior)
        part.append(index_element_prior)
        data_feature[index_element_prior] = num_part
        label_element = value['data'][1]['label']
        index_element = value['data'][1]['index']
        list_index.remove(index_element)
        for index in range(2, length_value):
            if ((not (label_element_prior == label_element)) or (not (label_element == value['data'][index]['label']))):
                discrete.append(part)
                part = list()
                num_part += 1
            part.append(index_element)
            data_feature[index_element] = num_part
            label_element_prior, index_element_prior = label_element, index_element
            label_element = value['data'][index]['label']
            index_element = value['data'][index]['index']
            list_index.remove(index_element)
        part.append(index_element)
        data_feature[index_element] = num_part
        discrete.append(part)
        size = 0
        for sub_part in discrete:
            size += len(sub_part)
        assert size == length_value, "Reveiw discreeting."
        if len(list_index) > 0:
            discrete.append(list_index)
            num_part += 1
            data_feature[list_index] = num_part
        entropy_feature = calculateEntropy(data_feature, discrete_feature, num_part)
        collections_discreeting.insert_one(
            {'feature': value['_id'], 'num_files': length_value, 'entropy_feature': entropy_feature,
             'discreeting': discrete, 'k': len(discrete)})
    collections_aux_discreeting.delete_one(feature)

def calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB, num_thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collections_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collections_discreeting.drop()
    collections_aux_discreeting = db.selectCollection(prefix_collection + '_aux_' + namesCollections[3])
    collections_aux_discreeting.drop()
    collection_features.aggregate([{'$group':{'_id':'$feature','num_files':{'$sum':1}}},
                                   {'$match':{'num_files':{'$gt':2}}},
                                   {'$out':prefix_collection + '_aux_' + namesCollections[3]}],allowDiskUse=True)
    discrete_feature = np.reshape(np.arange(0, lenghtDB, dtype=int), (1, lenghtDB))
    pool = Pool(num_thread)
    calculate_discreeting_one_element = partial(calculateDiscreetingOneElement, prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB, discrete_feature)
    while True:
        query = collections_aux_discreeting.aggregate([{'$match':{}}],allowDiskUse=True)
        try:
            pool.map(calculate_discreeting_one_element, query)
            pool.close()
            pool.join()
            query.close()
            break
        except CursorNotFound or AutoReconnect:
            continue
    del db



def calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, num_features, lenghtDB, num_thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2])
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$match': {}}, {'$out': prefix_collection + '_aux_' + namesCollections[2]}])
    collection_aux_ranking.create_index([('feature', ASCENDING)], unique=True)
    del collection_discreeting
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    collection_ranking_su.drop()
    collection_ranking_su.create_index([('feature_prior', ASCENDING),('feature', ASCENDING)], unique=True)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_mi')
    discrete=[[i for i in range(lenghtDB)]]
    entropy_class = calculateEntropy(data, discrete, 9)
    feature_prior=('label', discrete, entropy_class)
    del discrete, entropy_class
    for index in range(num_features):
        collection_aux2_ranking = db.selectCollection(prefix_collection + '_aux2_' + namesCollections[2])
        collection_aux2_ranking.drop()
        collection_aux_ranking.aggregate(
            [{'$sort': {'feature': 1}}, {'$project': {'_id': 0, 'feature': 1, 'entropy_feature': 1, 'discreeting': 1}},
             {'$out': prefix_collection + '_aux2_' + namesCollections[2]}], allowDiskUse=True)
        pool = Pool(num_thread)
        calculate_ranking_su = partial(calculateRankingSU, ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], data, 9, feature_prior)
        while True:
            query1 = collection_aux2_ranking.aggregate([{'$sort':{'feature':1}}],allowDiskUse=True)
            try:
                pool.map(calculate_ranking_su, query1)
                pool.close()
                pool.join()
                break
            except CursorNotFound or AutoReconnect:
                continue
        query_ranking = collection_ranking_su.aggregate(
            [{'$lookup':{'from':'train_rankingFeatures',
                         'localField':'feature',
                         'foreignField':'feature',
                         'as':'ranking'}},
             {'$unwind':'$ranking'},
             {'$group': {'_id': None, 'total_su': {'$sum': '$su'}, 'features': {'$addToSet': '$feature'}}},
             {'$project': {'_id': 0}}], allowDiskUse=True)
        try:
            elements_ranking = query_ranking.next()
        except Exception as e:
            elements_ranking = {'total_su': 0, 'features': []}
        del query1
        pool = Pool(num_thread)
        calculate_ranking_mi = partial(calculateRankingMI, ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], elements_ranking)
        collection_aux2_ranking.drop()
        collection_ranking_su.aggregate(
            [{'$match':{'feature_prior':feature_prior[0]}},
             {'$sort': {'feature': 1}},
             {'$out': prefix_collection + '_aux2_' + namesCollections[2]}], allowDiskUse=True)
        while True:
            query2 = collection_aux2_ranking.aggregate([{'$sort':{'feature':1}}],allowDiskUse=True)
            try:
                collection_ranking_mi.drop()
                collection_ranking_mi.create_index([('mi', DESCENDING), ('feature', ASCENDING)])
                pool.map(calculate_ranking_mi, query2)
                pool.close()
                pool.join()
                query2.close()
                break
            except CursorNotFound or AutoReconnect:
                continue
        del query2, calculate_ranking_mi
        best_mi = collection_ranking_mi.aggregate([{'$sort':{'mi':-1, 'feature':1}},{'$project':{'_id':0}},{'$limit':1}],allowDiskUse=True).next()
        best_mi['position'] = index
        feature_prior = (best_mi['feature'], best_mi['discreeting'], best_mi['entropy_class_feature'])
        collection_ranking.insert_one(best_mi)
        collection_aux_ranking.delete_one({'feature':best_mi['feature']})
    del db


def calculate_num_labels(data, array, labels):
    data_labels = np.ones(labels)
    for value in data[list(array)]:
        if value > 0:
            data_labels[value - 1] += 1
    return data_labels


def calculateEntropy(data, discrete, labels):
    entropy = np.zeros(len(discrete))
    total_elements = 0
    for index, array in enumerate(discrete):
        data_labels = calculate_num_labels(data, array, labels)
        num_elements_array = np.sum(data_labels)
        total_elements += num_elements_array
        data_labels = data_labels / num_elements_array
        entropy[index] = num_elements_array * (-np.sum(data_labels * np.log(data_labels)))
    return np.sum(entropy / total_elements)


def calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, name_collection, data, num_labels, feature_prior, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    collection_aux2_ranking = db.selectCollection(prefix_collection + '_aux2_' + name_collection)
    entropy_class_feature = calculateEntropy(data, feature['discreeting'], num_labels)
    su = (2*(feature_prior[2] - entropy_class_feature))/ (feature_prior[2] + feature['entropy_feature'])
    collection_ranking_su.save({'feature':feature['feature'], 'feature_prior':feature_prior[0], 'discreeting': feature['discreeting'], 'su':su, 'entropy_class_feature':entropy_class_feature})
    collection_aux2_ranking.delete_one(feature)
    del db, collection_ranking_su

def calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, name_collection, elements_ranking, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + name_collection + '_mi')
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    collection_aux2_ranking = db.selectCollection(prefix_collection + '_aux2_' + name_collection)
    array = list(elements_ranking['features'])
    array.append(feature['feature'])
    query_su = collection_ranking_su.aggregate([{'$match': {'feature_prior': {'$ne': 'label'},
                                                            'feature':{'$in':array}}},
                                                {'$group': {'_id': None,
                                                            'total_su': {'$sum': '$su'}}}], allowDiskUse=True)
    try:
        feature_su = query_su.next()['total_su']
    except Exception:
        feature_su = 0
    mi = elements_ranking['total_su']+collection_ranking_su.find_one({'feature':feature['feature'],'feature_prior':'label'})['su'] -(0.5*feature_su)
    feature['mi']=mi
    collection_ranking_mi.save(feature)
    collection_aux2_ranking.delete_one({'feature':feature['feature']})
    del db, collection_ranking_su, collection_ranking_mi
