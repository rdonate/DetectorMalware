#! - * - coding UTF-8 - * -

from src.mongo.database import DataBaseMongo
from pymongo import ASCENDING,DESCENDING
import numpy as np
from pymongo.errors import CursorNotFound, AutoReconnect
from multiprocessing import Pool
from functools import partial
import gc

def calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB, min_files_feature, num_labels, thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_discreeting.drop()
    collection_aux_discreeting = db.selectCollection(prefix_collection + '_aux_' + namesCollections[3])
    collection_aux_discreeting.drop()
    discrete_feature = np.reshape(np.arange(0, lenghtDB, dtype=int), (1, lenghtDB))
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    try:
        collection_features.aggregate([{'$group':{'_id':'$feature', 'kind':{'$first':'$kind'},'num_files':{'$sum':1}}},{'$match': {'num_files': {'$gt': min_files_feature}}},{'$project':{'_id':0, 'feature':'$_id','num_files':1, 'kind':1}},{'$out':prefix_collection + '_aux_' + namesCollections[3]}],allowDiskUse=True)
    except Exception as e:
        print('Review aggregation of features in calculateDiscretring. Error {}'.format(e))
    collection_aux_discreeting.create_index([('feature', ASCENDING)], unique=True)
    try:
        collection_features.create_index([('feature', ASCENDING),('n_count', ASCENDING), ('label',ASCENDING)])
    except Exception:
        print('Review create index on features in calculateDiscretring. Error {}'.format(e))
    while True:
        try:
            query = collection_aux_discreeting.aggregate([{'$project':{'_id': 0, 'feature': 1, 'kind': 1, 'num_files':1}},
                                                          {'$sort':{'num_files':-1}}],allowDiskUse=True)
            break
        except AutoReconnect:
            print('Review query in calculateDiscreeting.')
            continue
    pool = Pool(thread)
    calculate_element_discreeting = partial(calculateElementDiscreeting, ip_Server_Mongo, db_Name, prefix_collection,
                                        namesCollections, data, discrete_feature, num_labels, lenghtDB)
    try:
        pool.map(calculate_element_discreeting, query)
    except AutoReconnect:
        print('Review map in calculateDiscreeting.')
    collection_discreeting.create_index([('feature', ASCENDING)], unique=True)
    del db, collection_features, collection_discreeting, collection_aux_discreeting, discrete_feature, data, query, pool, calculate_element_discreeting
    gc.collect()


def calculateElementDiscreeting(ip_Server_Mongo, db_Name, prefix_collection, namesCollections, data, discrete_feature, num_labels, lenghtDB, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    while True:
        try:
            query_feature = collection_features.aggregate([{'$match':{'feature':feature['feature']}},
                                                           {'$sort':{'n_count':1,'label':1}},
                                                           {'$project':{'_id':0, 'label':1,'index_file':1,'n_count':1}}],
                                                          allowDiskUse=True)
            break
        except AutoReconnect:
            print('Review query in calculateElementDiscreeting for feature {}'.format(feature['feature']))
            continue
    discrete = list()
    part = np.array([])
    num_part = 1
    list_index = [index for index in range(lenghtDB)]
    data_feature = np.zeros(lenghtDB, dtype=int)
    value = query_feature.next()
    label_element_prior = value['label']
    index_element_prior = value['index_file']
    list_index.remove(index_element_prior)
    np.append(part, index_element_prior)
    data_feature[index_element_prior] = num_part
    value = query_feature.next()
    label_element = value['label']
    index_element = value['index_file']
    list_index.remove(index_element)
    for value in query_feature:
        if ((not (label_element_prior == label_element)) or (not (label_element == value['label']))):
            discrete.append(part)
            part = np.array([])
            num_part += 1
        np.append(part, index_element)
        data_feature[index_element] = num_part
        label_element_prior, index_element_prior = label_element, index_element
        label_element = value['label']
        index_element = value['index_file']
        list_index.remove(index_element)
    np.append(part, index_element)
    data_feature[index_element] = num_part
    discrete.append(part)
    if len(list_index) > 0:
        discrete.append(np.array(list_index))
        num_part += 1
        data_feature[list_index] = num_part
    discrete = np.array(discrete)
    entropy_feature = calculateEntropy(data_feature, discrete_feature, num_part)
    entropy_class_feature = calculateEntropy(data, discrete, num_labels)
    collection_discreeting.insert_one(
        {'feature': feature['feature'], 'num_files': feature['num_files'], 'entropy_feature': entropy_feature, 'entropy_class_feature':entropy_class_feature, 'kind': feature['kind'],'parts': num_part})
    del db, collection_discreeting, collection_features, query_feature, discrete, part, num_part, data_feature, label_element, label_element_prior, index_element_prior, index_element, list_index, value


def calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, num_features, lenghtDB, num_labels, thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2])
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$project':{'_id':0,'feature':1}}, {'$out': prefix_collection + '_aux_' + namesCollections[2]}])
    collection_aux_ranking.create_index([('feature', ASCENDING)], unique=True)
    del collection_discreeting
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    collection_ranking_su.drop()
    collection_ranking_su.create_index([('feature_prior', ASCENDING), ('feature', ASCENDING)], unique=True)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_mi')
    discrete = [[i for i in range(lenghtDB)]]
    entropy_class = calculateEntropy(data, discrete, num_labels)
    feature_prior = ('label', entropy_class)
    del entropy_class
    su_ranking_labels = 0
    su_ranking_not_labels = 0
    for index in range(num_features):
        while True:
            try:
                query = collection_aux_ranking.aggregate([{'$match':{}},{'$project':{'_id':0}}])
                break
            except AutoReconnect:
                continue
        pool = Pool(thread)
        calculateElementRankingSU = partial(calculateRankingSU, ip_Server_Mongo, db_Name, prefix_collection, namesCollections, feature_prior)
        try:
            pool.map(calculateElementRankingSU, query)
            pool.close()
            pool.join()
        except Exception as e:
            print(e)
        del query,pool,calculateElementRankingSU
        while True:
            try:
                query = collection_aux_ranking.aggregate([{'$match': {}}, {'$project': {'_id': 0}}])
                break
            except AutoReconnect:
                continue
        collection_ranking_mi.drop()
        collection_ranking_mi.create_index([('mi', DESCENDING), ('feature', ASCENDING)])
        pool = Pool(thread)
        calculateElementRankingMI = partial(calculateRankingMI, ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], su_ranking_labels, su_ranking_not_labels)
        try:
            pool.map(calculateElementRankingMI, query)
            pool.close()
            pool.join()
        except Exception as e:
            print(e)
        del query, pool, calculateElementRankingMI
        while True:
            try:
                best_mi = collection_ranking_mi.aggregate([{'$sort': {'mi': -1, 'feature': 1}},
                                                           {'$project': {'_id': 0,'feature':1,'total_su_not_label':1, 'mi':1}},
                                                           {'$limit': 1}], allowDiskUse=True).next()
                break
            except AutoReconnect:
                continue
        collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
        su_ranking_not_labels = best_mi['total_su_not_label']
        while True:
            try:
                su_label_best_mi = collection_ranking_su.find_one({'feature_prior':'label','feature':best_mi['feature']})['su']
                break
            except AutoReconnect:
                continue
        su_ranking_labels = su_ranking_labels + su_label_best_mi
        del su_label_best_mi
        while True:
            try:
                entropy_class_best_mi = collection_discreeting.find_one({'feature': best_mi['feature']})['entropy_class_feature']
                break
            except AutoReconnect:
                continue
        feature_prior = (best_mi['feature'],entropy_class_best_mi)
        del entropy_class_best_mi, collection_discreeting
        collection_ranking.insert_one({'feature':best_mi['feature'],'mi':best_mi['mi'], 'position':index})
        collection_aux_ranking.delete_one({'feature': best_mi['feature']})


def calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, name_collection, su_ranking_label, su_ranking_not_label, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + name_collection + '_mi')
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    while True:
        try:
            query_su = collection_ranking_su.aggregate([{'$match': {'feature_prior': {'$ne': 'label'},
                                                                    'feature':feature['feature']}},
                                                        {'$group': {'_id': None,
                                                                    'total_su': {'$sum': '$su'}}}], allowDiskUse=True)
            break
        except AutoReconnect:
            continue
    try:
        feature_su_not_label = query_su.next()['total_su'] + su_ranking_not_label
    except Exception:
        feature_su_not_label = su_ranking_not_label
    while True:
        try:
            su_feature = collection_ranking_su.find_one({'feature': feature['feature'], 'feature_prior': 'label'})['su']
            break
        except AutoReconnect:
            continue
    mi = su_ranking_label + su_feature - (0.5 * feature_su_not_label)
    feature['mi']=mi
    feature['total_su_not_label'] = feature_su_not_label
    collection_ranking_mi.save(feature)
    del db, collection_ranking_su, collection_ranking_mi

def calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, namesCollections, feature_prior, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    while True:
        try:
            feature_discreeting = collection_discreeting.find_one({'feature':feature['feature']})
            break
        except AutoReconnect:
            continue
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    su = (2*(feature_prior[1] - feature_discreeting['entropy_class_feature']))/ (feature_prior[1] + feature_discreeting['entropy_feature'])
    collection_ranking_su.save({'feature':feature['feature'], 'feature_prior':feature_prior[0], 'su':su})
    del db, collection_ranking_su,feature_discreeting,collection_discreeting,su


def calculate_num_labels(data, array, labels):
    data_labels = np.ones(labels)
    for value in data[list(array)]:
        if value > 0:
            data_labels[value - 1] += 1
    return data_labels


def calculateEntropy(data, discrete, labels):
    entropy = np.zeros(len(discrete))
    total_elements = 0
    for index, array in enumerate(discrete):
        data_labels = calculate_num_labels(data, array, labels)
        num_elements_array = np.sum(data_labels)
        total_elements += num_elements_array
        data_labels = data_labels / num_elements_array
        entropy[index] = num_elements_array * (-np.sum(data_labels * np.log(data_labels)))
    return np.sum(entropy / total_elements)
