#! - * - coding UTF-8 - * -

import re
import zipfile
from src.misc.string import arrayToString
from src.mongo.database import DataBaseMongo

def partition_bytes(line):
    if re.match(r'((([0-9A-F]{2})|\?\?) )*((([0-9A-F]{2})|\?\?) ) ', line):
        line= line.split('  ', maxsplit=1)
        line[0] = re.sub(r'^ +', '', line[0])
        line[0] = re.sub(r' +$', '', line[0])
        line[1] = re.sub(r'^ +', '', line[1])
        line[1] = re.sub(r' +$', '', line[1])
    elif re.match(r'((([0-9A-F]{2})|\?\?) )*((([0-9A-F]{2})|\?\?)\+)', line):
        line = re.split('\+', line, maxsplit=1)
        line[0] = line[0] + '+'
    elif re.match(r'^\s*(([0-9A-F]{2}|\?\?) )*([0-9A-F]{2}|\?\?)\+?\s*$', line):
        line = re.sub(r'^ +', '', line)
        line = re.sub(r' +$', '', line)
        line = [line]
    elif ' ' in line:
        flag=True
        index=0
        line = re.sub(r'^ +', '', line)
        line = re.sub(r' +$', '', line)
        auxline=re.split(r' +',line)
        while flag and index < len(auxline):
            if re.match(r'^(([0-9A-F]{2})|\?\?)\+?$',auxline[index]):
                index+=1
            else:
                flag = False
        line = [ arrayToString(auxline[:index]) , arrayToString(auxline[index:]) ]
        del auxline
    else:
        line = ['', line]
    return line

def extract_Features_Asm(prefix_collections, ip_Server_Mongo, db_Name, dir_Data_Raw, source, names_collections):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collections + '_' + names_collections[1])
    collection_total = db.selectCollection(prefix_collections + '_' + names_collections[0])
    with zipfile.ZipFile(dir_Data_Raw + prefix_collections + '.zip', 'r') as input_file:
        text=input_file.read(source[1]+'.asm').decode(encoding='iso8859')
    lines = re.findall('.*$',text,re.MULTILINE)
    instructions = {}
    sections = {}
    for line in lines:
        if not line == '':
            line_raw = re.sub(r'\r', '', line)
            line_raw = re.split(r';', line_raw, 1)[0]
            line_raw = re.sub(r'^ ', '', line_raw)
            line_raw = re.sub(r'\t', ' ', line_raw)
            line_raw = re.split(r':', line_raw, maxsplit=1)
            section = line_raw.pop(0).lower()
            if len(line_raw) == 1:
                line_raw = line_raw[0]
            else:
                line_raw = ''
            line_raw = re.split(r' ', line_raw, maxsplit=1)
            if len(line_raw) >0:
                dir = line_raw.pop(0)
            else:
                dir = ''
            if len(line_raw) == 1:
                line_raw = line_raw[0]
            else:
                line_raw = ''
            section = re.sub(r'[ .\%\&\?]+', '', section)
            if not re.match('^_+$', section):
                section = re.sub(r'_+', '', section)
            if not section in sections:
                sections[section] = set()
            sections[section].add(dir)
            del section
            if not re.match(r'^ *$', line_raw):
                line_raw = partition_bytes(line_raw)
                bytes = re.split(r' ', line_raw[0])
                line_raw.pop(0)
                if len(line_raw) == 1:
                    line_raw = line_raw[0]
                else:
                    line_raw = ' '
                line_raw = re.split(r'\s+', line_raw, maxsplit=1)
                instruction = line_raw.pop(0)
                if len(line_raw) == 1:
                    line_raw = line_raw[0]
                else:
                    line_raw = ''
                if '_' in instruction and not re.match(r'((^_)|(^\?+_))', instruction):
                    aux_instruction = re.split(r'_', instruction)
                    instruction = aux_instruction.pop(0)
                    line_raw = arrayToString(aux_instruction)+ ' ' + line_raw
                    del aux_instruction
                instruction = re.sub(r'_+','',instruction)
                instruction = re.sub(r'^\?+_?','',instruction)
                instruction = re.sub(r'(\s*:\s*|\s+=\s+|\s*,\s*)$','', instruction)
                line_raw = line_raw.strip()
                if ' ' in line_raw:
                    args = re.split(r' +', line_raw)
                else:
                    args = [line_raw]
                if instruction == 'call':
                    aux_instruction = re.sub(r'[\*_+\.:-@\?\$ ]+',' ', args.pop(0)).strip()
                    if re.match('^.\s',aux_instruction) and len(aux_instruction)>2:
                        aux_instruction = aux_instruction[2:]
                    if re.match('^\d{1}\D',aux_instruction):
                        aux_instruction = aux_instruction[1:]
                    instruction = instruction + ' ' + aux_instruction
                    del aux_instruction
            else:
                bytes = []
                instruction = ''
                args = []
            instruction = instruction.lower()
            instructions[instruction] = instructions.get(instruction, 0) + 1
    del line, line_raw, instruction
    total_instructions = 0
    for instruction in instructions.keys():
        if not instruction=='':
            total_instructions += instructions[instruction]
    for instruction in instructions.keys():
        if not instruction == '':
            data_instruction = {'index_file':source[0],'name_file': source[1], 'feature': 'a_' + instruction, 'count': instructions[instruction], 'n_count':instructions[instruction]/total_instructions,'kind':'asm'}
            if len(source)==3:
                data_instruction['label']= source[2]
            collection_features.insert(data_instruction)
    total_sections = 0
    for section in sections.keys():
        if not section=='':
            total_sections+=len(sections[section])
    for section in sections.keys():
        if not section == '':
            data_section = {'index_file':source[0],'name_file': source[1], 'feature': 's_' + section, 'count': len(sections[section]), 'n_count':len(sections[section])/total_sections, 'kind':'section'}
            if len(source)==3:
                data_section['label']= source[2]
            collection_features.insert(data_section)
    data_total = collection_total.update_one({'_id':source[0]}, {'$set':{'instructions':total_instructions,'sections':total_sections}})
    input_file.close()
    del db, collection_total, collection_features,  text, lines, instructions, sections, total_sections, total_instructions, data_total,  args, bytes, dir

