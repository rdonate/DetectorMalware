#! - * - coding UTF-8 - * -

from src.mongo.database import DataBaseMongo
from pymongo import ASCENDING,DESCENDING
import numpy as np
from pymongo.errors import CursorNotFound, AutoReconnect
from multiprocessing import Pool
from functools import partial
import gc

def calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB, min_files_feature, num_labels, thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_discreeting.drop()
    collection_aux_discreeting = db.selectCollection(prefix_collection + '_aux_' + namesCollections[3])
    collection_aux_discreeting.drop()
    collection_aux1_discreeting = db.selectCollection(prefix_collection + '_aux1_' + namesCollections[3])
    collection_aux1_discreeting.drop()
    discrete_feature = np.reshape(np.arange(0, lenghtDB, dtype=int), (1, lenghtDB))
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    try:
        collection_features.aggregate([{'$match':{'feature':'a_add'}},{'$group':{'_id':'$feature', 'kind':{'$first':'$kind'},'num_files':{'$sum':1}}},{'$project':{'_id':0, 'feature':'$_id','num_files':1, 'kind':1}},{'$out':prefix_collection + '_aux1_' + namesCollections[3]}],allowDiskUse=True)
    except Exception as e:
        print('Review aggregation of features in calculateDiscretring. Error {}'.format(e))
    try:
        collection_aux1_discreeting.aggregate([{'$match': {'num_files': {'$gt': min_files_feature}}},
                                               {'$project': {'_id': 0}},
                                               {'$out': prefix_collection + '_aux_' + namesCollections[3]}], allowDiskUse=True)
    except Exception as e:
        print('Review selection features with more of twice files in calculateDiscretring. Error {}'.format(e))
    while True:
        try:
            query = collection_aux_discreeting.aggregate([{'$project':{'_id': 0, 'feature': 1, 'kind': 1, 'num_files':1}},
                                                          {'$sort':{'feature':-1}}],allowDiskUse=True)
            break
        except AutoReconnect:
            print('Review query in calculateDiscreeting.')
            continue
    pool = Pool(thread)
    calculate_element_discreeting = partial(calculateElementDiscreeting, ip_Server_Mongo, db_Name, prefix_collection,
                                        namesCollections, data, discrete_feature, num_labels, lenghtDB)
    try:
        pool.map(calculate_element_discreeting, query)
    except AutoReconnect:
        print('Review map in calculateDiscreeting.')
    collection_discreeting.create_index([('feature', ASCENDING)], unique=True)
    del db, collection_features, collection_discreeting, collection_aux_discreeting, discrete_feature, data, query, pool, calculate_element_discreeting
    gc.collect()


def calculateElementDiscreeting(ip_Server_Mongo, db_Name, prefix_collection, namesCollections, data, discrete_feature, num_labels, lenghtDB, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    while True:
        try:
            query_feature = [elem for elem in collection_features.aggregate([{'$match':{'feature':feature['feature']}},
                                                                             {'$sort':{'n_count':1,'label':1}},
                                                                             {'$project':{'_id':0, 'label':1,'index_file':1,'n_count':1}}],
                                                                            allowDiskUse=True)]
            break
        except AutoReconnect:
            print('Review query in calculateElementDiscreeting for feature {}'.format(feature['feature']))
            continue
    discrete = list()
    part = list()
    num_part = 1
    list_index = [index for index in range(lenghtDB)]
    data_feature = np.zeros(lenghtDB, dtype=int)
    value = query_feature.pop(0)
    label_element_prior = value['label']
    index_element_prior = value['index_file']
    list_index.remove(index_element_prior)
    part.append(index_element_prior)
    data_feature[index_element_prior] = num_part
    value = query_feature.pop(0)
    label_element = value['label']
    index_element = value['index_file']
    list_index.remove(index_element)
    for value in query_feature:
        if ((not (label_element_prior == label_element)) or (not (label_element == value['label']))):
            discrete.append(part)
            part = list()
            num_part += 1
        part.append(index_element)
        data_feature[index_element] = num_part
        label_element_prior, index_element_prior = label_element, index_element
        label_element = value['label']
        index_element = value['index_file']
        list_index.remove(index_element)
    part.append(index_element)
    data_feature[index_element] = num_part
    discrete.append(part)
    if len(list_index) > 0:
        discrete.append(list_index)
        num_part += 1
        data_feature[list_index] = num_part
    entropy_feature = calculateEntropy(data_feature, discrete_feature, num_part)
    entropy_class_feature = calculateEntropy(data, discrete, num_labels)
    collection_discreeting.insert_one(
        {'feature': feature['feature'], 'num_files': feature['num_files'], 'entropy_feature': entropy_feature, 'entropy_class_feature':entropy_class_feature, 'kind': feature['kind'],
         'discreeting': discrete, 'parts': len(discrete)})
    del db, collection_discreeting, collection_features, query_feature, discrete, part, num_part, data_feature, label_element, label_element_prior, index_element_prior, index_element, list_index, value
    # gc.collect()


def calculateDiscreeting1(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, lenghtDB, min_files_feature, thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_discreeting.drop()
    discrete_feature = np.reshape(np.arange(0, lenghtDB, dtype=int), (1, lenghtDB))
    processed = 0
    while True:
        query = collection_features.aggregate([{'$sort': {'feature' : 1,
                                                          'n_count': -1,
                                                          'label': -1}},
                                               {'$group': {'_id': '$feature',
                                                           'data': {'$addToSet': {'index': '$index_file',
                                                                                  'label': '$label'}}}},
                                               {'$skip':processed}],
                                              allowDiskUse=True)
        try:
            for value in query:
                processed+=1
                discrete = list()
                part = list()
                num_part = 1
                length_value = len(value['data'])
                if length_value <= 2:
                    continue
                list_index = [index for index in range(lenghtDB)]
                data_feature = np.zeros(lenghtDB, dtype=int)
                label_element_prior = value['data'][0]['label']
                index_element_prior = value['data'][0]['index']
                list_index.remove(index_element_prior)
                part.append(index_element_prior)
                data_feature[index_element_prior]=num_part
                label_element = value['data'][1]['label']
                index_element = value['data'][1]['index']
                list_index.remove(index_element)
                for index in range(2, length_value):
                    if ((not (label_element_prior == label_element)) or (not (label_element == value['data'][index]['label']))):
                        discrete.append(part)
                        part = list()
                        num_part+=1
                    part.append(index_element)
                    data_feature[index_element]=num_part
                    label_element_prior, index_element_prior = label_element, index_element
                    label_element = value['data'][index]['label']
                    index_element = value['data'][index]['index']
                    list_index.remove(index_element)
                part.append(index_element)
                data_feature[index_element]=num_part
                discrete.append(part)
                size = 0
                for sub_part in discrete:
                    size += len(sub_part)
                assert size == length_value, "Reveiw discreeting."
                if len(list_index) > 0:
                    discrete.append(list_index)
                    num_part+=1
                    data_feature[list_index]=num_part
                entropy_feature = calculateEntropy(data_feature, discrete_feature, num_part)
                collection_discreeting.insert_one(
                    {'feature': value['_id'], 'num_files': length_value, 'entropy_feature':entropy_feature, 'kind':value['kind'], 'discreeting': discrete, 'k': len(discrete)})
            query.close()
            break
        except CursorNotFound:
            continue
    collection_discreeting.create_index([('feature', ASCENDING)], unique=True)
    del db


def calculateElementRanking(element):
    print(element)

def calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, num_features, lenghtDB, num_labels, thread):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2])
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$project':{'_id':0,'feature':1}}, {'$out': prefix_collection + '_aux_' + namesCollections[2]}])
    collection_aux_ranking.create_index([('feature', ASCENDING)], unique=True)
    del collection_discreeting
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    collection_ranking_su.drop()
    collection_ranking_su.create_index([('feature_prior', ASCENDING), ('feature', ASCENDING)], unique=True)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_mi')
    discrete = [[i for i in range(lenghtDB)]]
    entropy_class = calculateEntropy(data, discrete, num_labels)
    feature_prior = ('label', entropy_class)
    del entropy_class
    for index in range(num_features):
        while True:
            try:
                query = collection_aux_ranking.aggregate([{'$match':{}},{'$project':{'_id':0}}])
                break
            except AutoReconnect:
                continue
        pool = Pool(thread)
        calculateElementRankingSU = partial(calculateRankingSU, ip_Server_Mongo, db_Name, prefix_collection, namesCollections, data, num_labels, feature_prior)
        try:
            pool.map(calculateElementRankingSU, query)
            pool.close()
            pool.join()
        except AutoReconnect:
            pass
        del query,pool,calculateElementRankingSU
        while True:
            try:
                query_ranking_labels = collection_ranking_su.aggregate(
                    [{'$lookup': {'from': 'train_rankingFeatures',
                                  'localField': 'feature',
                                  'foreignField': 'feature',
                                  'as': 'ranking'}},
                     {'$unwind': '$ranking'},
                     {'$match':{'feature_prior':'label'}},
                     {'$group': {'_id': None, 'total_su': {'$sum': '$su'}}},
                     {'$project': {'_id': 0}}], allowDiskUse=True)
            except AutoReconnect:
                continue
            try:
                su_ranking_labels = query_ranking_labels.next()['total_su']
                break
            except AutoReconnect:
                continue
            except Exception:
                su_ranking_labels = 0
                break
        del query_ranking_labels
        while True:
            try:
                query_ranking_not_labels = collection_ranking_su.aggregate(
                    [{'$lookup': {'from': 'train_rankingFeatures',
                                  'localField': 'feature',
                                  'foreignField': 'feature',
                                  'as': 'ranking'}},
                     {'$unwind': '$ranking'},
                     {'$match':{'feature_prior':{'$ne':'label'}}},
                     {'$group': {'_id': None, 'total_su': {'$sum': '$su'}}},
                     {'$project': {'_id': 0}}], allowDiskUse=True)
                break
            except AutoReconnect:
                continue
        while True:
            try:
                su_ranking_not_labels = query_ranking_not_labels.next()['total_su']
                break
            except AutoReconnect:
                continue
            except Exception:
                su_ranking_not_labels = 0
                break
        del query_ranking_not_labels
        while True:
            try:
                query = collection_aux_ranking.aggregate([{'$match': {}}, {'$project': {'_id': 0}}])
                break
            except AutoReconnect:
                continue
        collection_ranking_mi.drop()
        collection_ranking_mi.create_index([('mi', DESCENDING), ('feature', ASCENDING)])
        pool = Pool(thread)
        calculateElementRankingMI = partial(calculateRankingMI, ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], su_ranking_labels, su_ranking_not_labels)
        try:
            pool.map(calculateElementRankingMI, query)
            pool.close()
            pool.join()
        except AutoReconnect:
            pass
        del query, su_ranking_labels, su_ranking_not_labels, pool, calculateElementRankingMI
        while True:
            try:
                best_mi = collection_ranking_mi.aggregate([{'$sort': {'mi': -1, 'feature': 1}},
                                                           {'$project': {'_id': 0,'feature':1}},
                                                           {'$limit': 1}], allowDiskUse=True).next()
                break
            except AutoReconnect:
                continue
        collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
        while True:
            try:
                discreeting_best_mi = collection_discreeting.find_one({'feature': best_mi['feature']})['discreeting']
                break
            except AutoReconnect:
                continue
        entropy_class_best_mi = calculateEntropy(data, discreeting_best_mi, num_labels)
        feature_prior = (best_mi['feature'],entropy_class_best_mi)
        del discreeting_best_mi,entropy_class_best_mi, collection_discreeting
        collection_ranking.insert_one({'feature':best_mi['feature'],'mi':best_mi['mi'], 'position':index})
        collection_aux_ranking.delete_one({'feature': best_mi['feature']})


def calculateRankingMI(ip_Server_Mongo, db_Name, prefix_collection, name_collection, su_ranking_label, su_ranking_not_label, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + name_collection + '_mi')
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    while True:
        try:
            query_su = collection_ranking_su.aggregate([{'$match': {'feature_prior': {'$ne': 'label'},
                                                                    'feature':feature['feature']}},
                                                        {'$group': {'_id': None,
                                                                    'total_su': {'$sum': '$su'}}}], allowDiskUse=True)
            break
        except AutoReconnect:
            continue
    try:
        feature_su = query_su.next()['total_su'] + su_ranking_not_label
    except Exception:
        feature_su = su_ranking_not_label
    while True:
        try:
            su_feature = collection_ranking_su.find_one({'feature': feature['feature'], 'feature_prior': 'label'})['su']
            break
        except AutoReconnect:
            continue
    mi = su_ranking_label + su_feature - (0.5 * feature_su)
    feature['mi']=mi
    collection_ranking_mi.save(feature)
    del db, collection_ranking_su, collection_ranking_mi

def calculateRankingSU(ip_Server_Mongo, db_Name, prefix_collection, namesCollections, data, num_labels, feature_prior, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    while True:
        try:
            feature_discreeting = collection_discreeting.find_one({'feature':feature['feature']})
            break
        except AutoReconnect:
            continue
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    entropy_class_feature = calculateEntropy(data, feature_discreeting['discreeting'], num_labels)
    su = (2*(feature_prior[1] - entropy_class_feature))/ (feature_prior[1] + feature_discreeting['entropy_feature'])
    collection_ranking_su.save({'feature':feature['feature'], 'feature_prior':feature_prior[0], 'su':su})
    del db, collection_ranking_su,feature_discreeting,collection_discreeting,entropy_class_feature,su

def calculateRanking1(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, num_features, lenghtDB):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3])
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2])
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2])
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$match': {}}, {'$out': prefix_collection + '_aux_' + namesCollections[2]}])
    collection_aux_ranking.create_index([('feature', ASCENDING)], unique=True)
    del collection_discreeting
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_su')
    collection_ranking_su.drop()
    collection_ranking_su.create_index([('feature_prior', ASCENDING),('feature', ASCENDING)], unique=True)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_mi')
    discrete=[[i for i in range(lenghtDB)]]
    entropy_class = calculateEntropy(data, discrete, 9)
    feature_prior=('label', discrete, entropy_class)
    del discrete, entropy_class
    for index in range(num_features):
        processed1 = 0
        while True:
            query1 = collection_aux_ranking.aggregate(
                [{'$sort': {'feature': 1}}, {'$project': {'_id': 0, 'feature': 1, 'entropy_feature':1, 'discreeting': 1}},{'$skip':processed1}], allowDiskUse=True)
            try:
                for feature1 in query1:
                    calculateRankingSU1(ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2] + '_su', data, 9, feature_prior, feature1)
                    processed1+=1
                query1.close()
                break
            except CursorNotFound:
                continue
        query_ranking = collection_ranking_su.aggregate(
            [{'$lookup':{'from':'train_rankingFeatures',
                         'localField':'feature',
                         'foreignField':'feature',
                         'as':'ranking'}},
             {'$unwind':'$ranking'},
             {'$group': {'_id': None, 'total_su': {'$sum': '$su'}, 'features': {'$addToSet': '$feature'}}},
             {'$project': {'_id': 0}}], allowDiskUse=True)
        try:
            elements_ranking = query_ranking.next()
        except Exception as e:
            elements_ranking = {'total_su': 0, 'features': []}
        del query1, feature1, processed1
        processed2=0
        while True:
            try:
                query2 = collection_ranking_su.aggregate(
                    [{'$match':{'feature_prior':feature_prior[0]}},
                     {'$sort': {'feature': 1}},
                     {'$skip':processed2}], allowDiskUse=True)
                collection_ranking_mi.drop()
                collection_ranking_mi.create_index([('mi', DESCENDING), ('feature', ASCENDING)])
                for feature2 in query2:
                    calculateRankingMI1(ip_Server_Mongo, db_Name, prefix_collection, namesCollections[2], elements_ranking, feature2)
                    processed2+=1
                query2.close()
                break
            except CursorNotFound:
                continue
        del feature2, query2, processed2
        best_mi = collection_ranking_mi.aggregate([{'$sort':{'mi':-1, 'feature':1}},{'$project':{'_id':0}},{'$limit':1}],allowDiskUse=True).next()
        best_mi['position'] = index
        feature_prior = (best_mi['feature'], best_mi['discreeting'], best_mi['entropy_class_feature'])
        collection_ranking.insert_one(best_mi)
        collection_aux_ranking.delete_one({'feature':best_mi['feature']})
    del db


def calculate_num_labels(data, array, labels):
    data_labels = np.ones(labels)
    for value in data[list(array)]:
        if value > 0:
            data_labels[value - 1] += 1
    return data_labels


def calculateEntropy(data, discrete, labels):
    entropy = np.zeros(len(discrete))
    total_elements = 0
    for index, array in enumerate(discrete):
        data_labels = calculate_num_labels(data, array, labels)
        num_elements_array = np.sum(data_labels)
        total_elements += num_elements_array
        data_labels = data_labels / num_elements_array
        entropy[index] = num_elements_array * (-np.sum(data_labels * np.log(data_labels)))
    return np.sum(entropy / total_elements)


def calculateRankingSU1(ip_Server_Mongo, db_Name, prefix_collection, name_collection, data, num_labels, feature_prior, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection)
    entropy_class_feature = calculateEntropy(data, feature['discreeting'], num_labels)
    su = (2*(feature_prior[2] - entropy_class_feature))/ (feature_prior[2] + feature['entropy_feature'])
    collection_ranking_su.insert_one({'feature':feature['feature'], 'feature_prior':feature_prior[0], 'discreeting': feature['discreeting'], 'su':su, 'entropy_class_feature':entropy_class_feature})
    del db, collection_ranking_su

def calculateRankingMI1(ip_Server_Mongo, db_Name, prefix_collection, name_collection, elements_ranking, feature):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_ranking_mi = db.selectCollection(prefix_collection + '_' + name_collection + '_mi')
    collection_ranking_su = db.selectCollection(prefix_collection + '_' + name_collection + '_su')
    array = list(elements_ranking['features'])
    array.append(feature['feature'])
    query_su = collection_ranking_su.aggregate([{'$match': {'feature_prior': {'$ne': 'label'},
                                                            'feature':{'$in':array}}},
                                                {'$group': {'_id': None,
                                                            'total_su': {'$sum': '$su'}}}], allowDiskUse=True)
    try:
        feature_su = query_su.next()['total_su']
    except Exception:
        feature_su = 0
    mi = elements_ranking['total_su']+collection_ranking_su.find_one({'feature':feature['feature'],'feature_prior':'label'})['su'] -(0.5*feature_su)
    feature['mi']=mi
    collection_ranking_mi.insert_one(feature)
    del db, collection_ranking_su, collection_ranking_mi
