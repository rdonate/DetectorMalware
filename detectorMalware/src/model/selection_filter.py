from ..mongo.database import DataBaseMongo
from pymongo import ASCENDING
import json
import bson
import numpy as np
from .comparation_condiction_preprocess import comparation_preprocess

def funtion_condition_c45():
    def aux_funtion_condition_c45(element_prior, element, element_next):
        return ((not (element_prior == element)) or (not (element == element_next)))
    return aux_funtion_condition_c45

def funtion_condition_my_discreet():
    def aux_funtion_condition_my_discreet(element_prior, element, element_next):
        return ((not (element_prior == element)) and (element == element_next))
    return aux_funtion_condition_my_discreet

def union_partition(data, partition1, partition2):
    partition1_set=[]
    for elem_part1 in partition1:
        partition1_set.append(set(elem_part1))
    partition2_set = []
    for elem_part2 in partition2:
        partition2_set.append(set(elem_part2))
    new_partition=[]
    index_part1=0
    index_part2=0
    elements_selects = list()
    while ((not (len(partition1_set)==0)) and (not (len(partition2_set)==0)) and (len(partition1_set)>index_part1)):
        insersect = partition1_set[index_part1] & partition2_set[index_part2]
        elements_selects.extend(list(insersect))
        if len(insersect)==0:
            index_part2+=1
            if index_part2 >= len(partition2_set):
                index_part1 += 1
                index_part2 = 0
        else:
            new_partition.append(list(insersect))
            elem_part1 = partition1_set.pop(index_part1)
            elem_part2 =partition2_set.pop(index_part2)
            if len(elem_part1-insersect)>0:
                partition1_set.append(elem_part1-insersect)
            if len(elem_part2-insersect)>0:
                partition2_set.append(elem_part2 - insersect)
            index_part2=0
    for elem_part1 in partition1_set:
        new_partition.append(list(elem_part1))
    for elem_part2 in partition2_set:
        new_partition.append(list(elem_part2))
    data[elements_selects]=data[elements_selects]*(-1)
    return data,new_partition

def selection_filter(prefix_collection, ip_Server_Mongo, db_Name, names_collections, thread, lengtnDB, seed):
    conditions={'c45':funtion_condition_c45(), 'my_discreet': funtion_condition_my_discreet()}
    calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, names_collections, conditions)
    for condition in conditions:
        calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, names_collections, condition)
    # best_ranking = comparation_preprocess(prefix_collection, ip_Server_Mongo, db_Name, names_collections, conditions.keys())
    # db = DataBaseMongo(ip_Server_Mongo, db_Name)
    # collection_best_ranking=db.selectCollection(prefix_collection + '_' + names_collections[2] + '_' + best_ranking)
    # collection_best_ranking.rename(prefix_collection + '_' + names_collections[2])
    # for condition in conditions:
    #     db.selectCollection(prefix_collection + '_' + names_collections[2] + '_' + condition).drop()
    # del db, collection_best_ranking,conditions,best_ranking

def calculateRanking(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, name_condition, num_features):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_total = db.selectCollection(prefix_collection + '_' + namesCollections[0])
    data = np.array([value['label'] for value in
                     collection_total.aggregate([{'$project': {'_id': 1, 'label': 1}}, {'$sort': {'_id': 1}}])])
    del collection_total
    collection_discreeting = db.selectCollection(prefix_collection + '_' + namesCollections[3] + '_' + name_condition)
    collection_ranking = db.selectCollection(prefix_collection + '_' + namesCollections[2] + '_' + name_condition)
    collection_ranking.drop()
    collection_aux_ranking = db.selectCollection(prefix_collection + '_aux_' + namesCollections[2] + '_' + name_condition)
    collection_aux_ranking.drop()
    collection_discreeting.aggregate([{'$match':{}},{'$out':prefix_collection + '_aux_' + namesCollections[2] + '_' + name_condition}])
    collection_aux_ranking.create_index([('feature', ASCENDING)],unique=True)
    list_features = ['' for i in range(num_features)]
    # num_features = collection_discreeting.count()
    del collection_discreeting
    partition_prior = np.reshape(np.arange(0,len(data)),(1,len(data)))
    for position in range(num_features):
        best_su = None
        query = collection_aux_ranking.aggregate([{'$sort':{'feature':1}}],allowDiskUse=True)
        for index,element in enumerate(query):
            if index%1000000==0:
                print(index)
            su = calculateSymmetricUncertainty(data,element['discreeting'],partition_prior,9)
            if ((best_su == None) or (su > best_su['su']) or ((su==best_su['su']) and (element['num_files']>best_su['num_files']))):
                best_su=element
                best_su['su']=su
        collection_aux_ranking.delete_one({'_id':best_su['_id']})
        # best_su['position']=position
        data, partition_prior = union_partition(data, partition_prior, best_su['discreeting'])
        list_features[position]=best_su['feature']
        # collection_ranking.insert_one({'feature':best_su['feature'], 'su':best_su['su'], 'num_files':best_su['num_files'], 'position':best_su['position'], 'k':best_su['k']})


def calculateDiscreeting(prefix_collection, ip_Server_Mongo, db_Name, namesCollections, conditions):
    db = DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection + '_' + namesCollections[1])
    collections_discreeting =dict()
    for condition in conditions:
        collections_discreeting[condition]=db.selectCollection(prefix_collection + '_' + namesCollections[3] + '_' + condition)
        collections_discreeting[condition].drop()
        query = collection_features.aggregate([{'$sort': {'feature' : -1,
                                                          'n_count': -1,
                                                          'label': -1}},
                                               {'$group': {'_id': '$feature',
                                                           'data': {'$addToSet': {'index': '$index_file',
                                                                                  'label': '$label'}}}}],
                                              allowDiskUse=True)
        for value in query:
            discrete = list()
            part = list()
            length_value = len(value['data'])
            if length_value<=9:
                continue
            label_element_prior = value['data'][0]['label']
            index_element_prior = value['data'][0]['index']
            part.append(index_element_prior)
            label_element = value['data'][1]['label']
            index_element = value['data'][1]['index']
            for index in range(2, length_value):
                if conditions[condition](label_element_prior,label_element,value['data'][index]['label']):
                    discrete.append(part)
                    part = list()
                part.append(index_element)
                label_element_prior, index_element_prior = label_element, index_element
                label_element = value['data'][index]['label']
                index_element = value['data'][index]['index']
            part.append(index_element)
            discrete.append(part)
            size = 0
            for sub_part in discrete:
                size += len(sub_part)
            assert size == length_value, "Reveiw discreeting."
            collections_discreeting[condition].insert_one({'feature': value['_id'], 'num_files':length_value, 'discreeting': discrete, 'k': len(discrete)})

def calculate_num_labels(data, array, labels):
    data_labels = np.ones(labels)
    for value in data[array]:
        if value > 0:
            data_labels[value - 1] += 1
    return data_labels

def calculateEntropy(data, discrete,labels):
    entropy = np.zeros(len(discrete))
    total_elements = 0
    for index, array in enumerate(discrete):
        length_array = len(array)
        total_elements += (length_array+labels)
        data_labels = calculate_num_labels(data, array, labels)
        data_labels = data_labels / np.sum(data_labels)
        entropy[index] = length_array * (-np.sum(data_labels * np.log(data_labels)))
    return np.sum(entropy / total_elements)

def calculateGainInformationModify(data, discrete, discrete_prior, num_labels):
    entropy_class = calculateEntropy(data, discrete_prior, num_labels)
    entropy_class_feature = calculateEntropy(data, discrete, num_labels)
    return entropy_class - entropy_class_feature

def calculateSymmetricUncertainty(data, discrete, discrete_prior, num_labels):
    entropy_class = calculateEntropy(data, discrete_prior, num_labels)
    feature = np.zeros(len(data), dtype=int)
    for index, value in enumerate(discrete):
        for aux_value in value:
            feature[aux_value]=index+1
    discrete_feature = np.reshape(np.arange(0, len(data)), (1, len(data)))
    entropy_featue = calculateEntropy(feature, discrete_feature, len(discrete))
    gain_information = calculateGainInformationModify(data, discrete, discrete_prior, num_labels)
    return (2*gain_information)/(entropy_featue+entropy_class)