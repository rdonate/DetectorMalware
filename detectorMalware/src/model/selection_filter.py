from ..mongo.database import DataBaseMongo
from scipy.stats import rv_continuous
'''agrupación para obtener las caracteristicas seleccionadas, le falta la projección al principio
db.train_asm.aggregate([{
    '$group':{
        '_id':'$file',
        'instructions': {
            '$addToSet':{
                '$arrayElemAt':[
                {'$zip':{
                    'inputs':[['$instruction'],['$count']]}},0]}}}}],{allowDiskUse:true})

db.train_total.aggregate([
        {'$lookup':{'from':'train_asm','localField':'_id','foreignField':'file','as':'asm'}},
        {'$lookup':{'from':'train_section','localField':'_id','foreignField':'file','as':'section'}},
        {'$project':{'class':1,'features':{'$setUnion':['$asm','$section']}}},
        {'$project':{'features.file':0,'features.class':0,'features._id':0}},
        
    ],
    {allowDiskUse:true})

'''

def selection_filter(prefix_collection, ip_Server_Mongo, db_Name, names_Collections):
    db=DataBaseMongo(ip_Server_Mongo, db_Name)
    collection_features = db.selectCollection(prefix_collection+'_'+names_Collections[1])
    #collection_asm=db.selectCollection('train_'+name_Collections[2])
    collection_total = db.selectCollection('train_' + names_Collections[0])
    #a=collection_asm.aggregate([{'$group':{'_id':'$file', 'instructions': {'$addToSet':{'$arrayElemAt':[{'$zip':{'inputs':[['$instruction'],['$count']]}},0]}}}}],True)
    a = collection_total.aggregate([
        {'$lookup':{'from':'train_asm','localField':'_id','foreignField':'file','as':'asm'}},
        {'$lookup':{'from':'train_section','localField':'_id','foreignField':'file','as':'section'}},
        {'$project':{'class':1,'features':{'$setUnion':['$asm','$section']}}},
        {'$project':{'features.file':0,'features.class':0,'features._id':0,'features.kind':1}},

    ],
        allowDiskUse=True)
    return []


def calculateGainInformationModify(db,prefix_collection,names_Collections,variable, kind):
    return (calculateEntropy(db,prefix_collection,names_Collections,'class')-calculateEntropy('class',variable))/calculateEntropy('feature')

def calculateEntropy(db,prefix_collection,names_Collections, variable, condition='null'):
    collection=db.selectCollection(prefix_collection+'_'+names_Collections[1])
    if condition=='null':
        valuesDB=collection.aggregate([
            {'$group':{'_id':{variable:'$'+variable,'condition':condition}, 'countClass':{'$sum':'$count'}}},
            {'$project':{'_id':0, variable:'$_id.'+variable, 'condition':'$_id.condition', 'countClass':1}},
            {'$sort':{'condition':1, 'class':1}}])
    else:
        valuesDB = collection.aggregate([
            {'$match': {'feature':condition}},
            {'$group': {'_id': {variable: '$' + variable}, 'countEntrophy': {'$sum': '$count'}}},
            {'$project': {'_id': 0, 'class': '$_id.class', 'condition': '$feature', 'countEntrophy': 1}},
            {'$sort': {'condition': 1, 'class': 1}}])
    values={}
    totalVariable=0
    for value in valuesDB:
        if not value['condition'] in values:
            values[value['condition']] = []
            values[value['condition']][0] = []
            values[value['condition']][1] = totalCondition
            totalVariable+=totalCondition
            totalCondition=0
        values[value['condition']][0][value['class']-1]=value['countEntrophy']
        totalCondition+=value['countEntrophy']

    entropy=rv_continuous.entropy()
    pass

def calculateSymmetricUncertainty(variable, kind):
    return (2*calculateGainInformationModify(variable,kind))/(calculateEntropy(variable)+calculateEntropy(kind))